//
//  main.m
//  ReceiptValidator
//
//  Created by Joachim Deelen on 11.04.13.
//  Copyright (c) 2013 micabo software UG. All rights reserved.
//

#import <Foundation/Foundation.h>
#import <openssl/objects.h>
#import <openssl/pkcs7.h>
#import <openssl/asn1.h>
#import <Security/Security.h>

#import "ASN/Payload.h"

NSDictionary* DictionaryFromPayload(PKCS7 *_pkcs7Container);

static NSString *kReceiptBundleIdentifer = @"BundleIdentifier";
static NSString *kReceiptBundleIdentiferData = @"BundleIdentifierData";
static NSString *kReceiptVersion = @"Version";
static NSString *kReceiptOpaqueValue = @"OpaqueValue";
static NSString *kReceiptHash = @"Hash";

int main(int argc, const char * argv[])
{

	@autoreleasepool {

		// Load the Receipt into a NSData
		NSURL *receiptURL = [NSURL fileURLWithPath:@"./receipt"];
		NSData *receiptPKCS7Data = [NSData dataWithContentsOfURL:receiptURL];

		// Import the Data as SecItems. This extracts the Certificates
		SecExternalFormat itemFormat = kSecFormatPKCS7;
		SecExternalItemType itemType = kSecItemTypeUnknown;
		CFArrayRef outItems;
		SecItemImport((__bridge CFDataRef)receiptPKCS7Data, NULL, &itemFormat, &itemType, kSecItemPemArmour, 0, NULL, &outItems);

		NSArray *items = CFBridgingRelease(outItems);

		SecCertificateRef firstCert = (__bridge SecCertificateRef)[items objectAtIndex:0];
		CFErrorRef error;
		CFDictionaryRef valueDict = SecCertificateCopyValues(firstCert, NULL, &error);

		SecCertificateRef secondCert = (__bridge SecCertificateRef)[items objectAtIndex:1];
		valueDict = SecCertificateCopyValues(secondCert, NULL, &error);

		SecCertificateRef thirdCert = (__bridge SecCertificateRef)[items objectAtIndex:2];
		valueDict = SecCertificateCopyValues(thirdCert, NULL, &error);


		// Decode the PCKS7-Container
		CMSDecoderRef decoder;
		CMSDecoderCreate(&decoder);
		OSStatus rc = CMSDecoderUpdateMessage(decoder, [receiptPKCS7Data bytes], [receiptPKCS7Data length]);
		rc = CMSDecoderFinalizeMessage(decoder);

		// Extract the Raw-Paylod
		CFDataRef content;
		CMSDecoderCopyContent(decoder, &content);

		size_t numberOfSigners;
		CMSDecoderGetNumSigners(decoder, &numberOfSigners);

		SecTrustRef trustRef = NULL;
		SecPolicyRef policyRef = SecPolicyCreateBasicX509();

		CMSSignerStatus signerStatus = kCMSSignerUnsigned;
		OSStatus certVerifyResult = noErr;
		rc = CMSDecoderCopySignerStatus(decoder, 0, policyRef, TRUE, &signerStatus, &trustRef, &certVerifyResult);


		/* The receipt payload and its size. */
		void *pld = (void *)CFDataGetBytePtr(content);
		size_t pld_sz = CFDataGetLength(content);

		/* Variables used to parse the payload. Both data types are declared in Payload.h. */
		Payload_t *payload = NULL;
		asn_dec_rval_t rval;

		/* Parse the buffer using the decoder function generated by asn1c.  The payload variable will contain the receipt attributes. */
		rval = asn_DEF_Payload.ber_decoder(NULL, &asn_DEF_Payload, (void **)&payload, pld, pld_sz, 0);

		enum ATTRIBUTES {
			ATTR_START = 1,
			BUNDLE_ID,
			VERSION,
			OPAQUE_VALUE,
			HASH,
			ATTR_END
		};

		NSMutableDictionary *attributes = [NSMutableDictionary dictionary];

		/* Iterate over the receipt attributes, saving the values needed to compute the GUID hash. */
		size_t i;
		for (i = 0; i < payload->list.count; i++) {
			ReceiptAttribute_t *entry;

			entry = payload->list.array[i];

			switch (entry->type) {
				case BUNDLE_ID:
					[attributes setObject:[NSData dataWithBytes:entry->value.buf length:entry->value.size] forKey:kReceiptBundleIdentiferData];
					[attributes setObject:[[NSString alloc] initWithData:[attributes objectForKey:kReceiptBundleIdentiferData] encoding:NSUTF8StringEncoding] forKey:kReceiptBundleIdentifer];
//					[attributes setObject:[[NSString alloc] initWithBytes:entry->value.buf length:entry->value.size encoding:NSUTF8StringEncoding] forKey:kReceiptBundleIdentifer];
					break;

				case VERSION:
					[attributes setObject:[[NSString alloc] initWithBytes:entry->value.buf length:entry->value.size encoding:NSUTF8StringEncoding] forKey:kReceiptVersion];
					break;

				case OPAQUE_VALUE:
					[attributes setObject:[NSData dataWithBytes:entry->value.buf length:entry->value.size] forKey:kReceiptOpaqueValue];
					break;

				case HASH:
					[attributes setObject:[NSData dataWithBytes:entry->value.buf length:entry->value.size] forKey:kReceiptHash];
					break;
			}
		}
		
		NSLog(@"PKCS7: %p", items);

/*

		NSInputStream *inputStream = [NSInputStream inputStreamWithURL:receiptURL];
		SecTransformRef readTransform = SecTransformCreateReadTransformWithReadStream((__bridge CFReadStreamRef)inputStream);
		SecTransformRef decodeTransform = SecDecodeTransformCreate(NULL, &error);
		SecGroupTransformRef group = SecTransformCreateGroupTransform();

		SecTransformConnectTransforms(readTransform, kSecTransformOutputAttributeName, decodeTransform, kSecTransformInputAttributeName, group, &error);
		NSData *pkcs7Data = nil;
//		SecTransformSetAttribute(readTransform, kSecTransformOutputAttributeName, (__bridge CFDataRef)pkcs7Data, &error);
		pkcs7Data = (__bridge NSData*)SecTransformExecute(group, &error);
		PKCS7 *_pkcs7Container = (PKCS7*)[pkcs7Data bytes];
		NSDictionary *attributes = DictionaryFromPayload(_pkcs7Container);
*/

	}
    return 0;
}


NSDictionary* DictionaryFromPayload(PKCS7 *pkcs7Container)
{
    enum ATTRIBUTES {
        ATTR_START = 1,
        BUNDLE_ID,
        VERSION,
        OPAQUE_VALUE,
        HASH,
        ATTR_END
    };

	if(!PKCS7_type_is_signed(pkcs7Container)) {
		return nil;
	}

	if(!PKCS7_type_is_data(pkcs7Container->d.sign->contents)) {
		return nil;
	}

	ASN1_OCTET_STRING *octets = pkcs7Container->d.sign->contents->d.data;
	const unsigned char *p = octets->data;
	const unsigned char *end = p + octets->length;

	int type = 0;
	int xclass = 0;
	long length = 0;

	ASN1_get_object(&p, &length, &type, &xclass, end - p);
	if(type != V_ASN1_SET) {
		return nil;
	}

    NSMutableDictionary *info = [NSMutableDictionary dictionary];

	while (p < end) {
		ASN1_get_object(&p, &length, &type, &xclass, end - p);
		if(type != V_ASN1_SEQUENCE) {
			break;
		}

		const unsigned char *seq_end = p + length;

		int attr_type = 0;
		int attr_version = 0;

		// Attribute type
        ASN1_get_object(&p, &length, &type, &xclass, seq_end - p);
		if(type == V_ASN1_INTEGER && length == 1) {
			attr_type = p[0];
		}
		p += length;

		// Attribute version
		ASN1_get_object(&p, &length, &type, &xclass, seq_end - p);
		if(type == V_ASN1_INTEGER && length == 1) {
			attr_version = p[0];
		}
		p += length;

		// Only parse attributes we're interested in
		if (attr_type > ATTR_START && attr_type < ATTR_END) {
			NSString *key;

			ASN1_get_object(&p, &length, &type, &xclass, seq_end - p);
			if(type == V_ASN1_OCTET_STRING) {

				// Bytes
				if(attr_type == BUNDLE_ID || attr_type == OPAQUE_VALUE || attr_type == HASH) {
					NSData *data = [NSData dataWithBytes:p length:(NSUInteger)length];

					switch (attr_type) {
						case BUNDLE_ID:
							// This is included for hash generation
							key = kReceiptBundleIdentiferData;
							break;
						case OPAQUE_VALUE:
							key = kReceiptOpaqueValue;
							break;
						case HASH:
							key = kReceiptHash;
							break;
					}

					[info setObject:data forKey:key];
				}

				// Strings
				if(attr_type == BUNDLE_ID || attr_type == VERSION) {
					int str_type = 0;
					long str_length = 0;
					const unsigned char *str_p = p;
					ASN1_get_object(&str_p, &str_length, &str_type, &xclass, seq_end - str_p);
					if(str_type == V_ASN1_UTF8STRING) {
						NSString *string = [[NSString alloc] initWithBytes:str_p
																	 length:(NSUInteger)str_length
																   encoding:NSUTF8StringEncoding];

						switch(attr_type) {
							case BUNDLE_ID:
								key = kReceiptBundleIdentifer;
								break;
							case VERSION:
								key = kReceiptVersion;
								break;
						}

						[info setObject:string forKey:key];
					}
				}
			}
			p += length;
		}

		// Skip any remaining fields in this SEQUENCE
		while (p < seq_end) {
			ASN1_get_object(&p, &length, &type, &xclass, seq_end - p);
			p += length;
		}
	}
	return info;
}

